<!DOCTYPE html>
<body>
<style>
html, body {
  margin: 0px;
  border: none;
  padding: 0px;
  width: 100%;
  height: 100%;
}

body {
  display: flex;
}

#mainCanvas {
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
}

#controls {
  position: absolute;
  margin: 20px;
  top: 0px;
  left: 0px;
  padding: 20px;
  background-color: hsla(0deg, 0%, 12.5%, 1);
  color: white;
  border: 2px solid hsla(0deg, 0%, 25%, 1);
  border-radius: 4px;
}

#controlsGrid {
  display: grid;
  grid: 1fr / auto 1fr;
  gap: 4px;
}

input {
  width: clamp(100px, 50vw, 900px);
}
</style>
<canvas id="mainCanvas" width="640" height="640"></canvas>
<details id="controls">
  <summary>Controls</summary>
  <hr>
  <div id="controlsGrid">
    <span>iterations</span>
    <input type="range" id="iterationsRange" min="0" max="1024" step="1" value="256">
    <span>a</span>
    <input type="range" id="aRange" min="-1" max="1" step="0.000001" value="0.31">
    <span>b</span>
    <input type="range" id="bRange" min="-1" max="1" step="0.000001" value="0.5">
  </div>
</details>

<script type="module">
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();

const buffer = device.createBuffer({
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  size:
    /* viewMatrix */ 16 * Float32Array.BYTES_PER_ELEMENT +
    /* iterations */ 1 * Float32Array.BYTES_PER_ELEMENT +
    /* a */ 1 * Float32Array.BYTES_PER_ELEMENT +
    /* b */ 1 * Float32Array.BYTES_PER_ELEMENT +
    0,
});

const bindGroupLayout = device.createBindGroupLayout({
  entries: [{
    binding: 0,
    visibility: GPUShaderStage.FRAGMENT,
    buffer: {
      type: "storage",
    },
  }],
});

const bindGroup = device.createBindGroup({
  layout: bindGroupLayout,
  entries: [{
    binding: 0,
    resource: {
      buffer: buffer,
    },
  }],
});

const renderPipeline = device.createRenderPipeline({
  layout: device.createPipelineLayout({
    bindGroupLayouts: [bindGroupLayout],
  }),
  vertex: {
    entryPoint: "main",
    module: device.createShaderModule({
      code: await (await fetch("./main.vert.wgsl")).text(),
    }),
  },
  fragment: {
    targets: [{
      format: "bgra8unorm",
    }],
    entryPoint: "main",
    module: device.createShaderModule({
      code: await (await fetch("./main.frag.wgsl")).text(),
    }),
  },
});

const mainCanvas = document.getElementById("mainCanvas");
const context = mainCanvas.getContext("webgpu");
context.configure({
  device,
  format: context.getPreferredFormat(adapter),
});

const viewMatrix = new DOMMatrix();
const aspectRatio = mainCanvas.width / mainCanvas.height;
viewMatrix.scaleSelf(
  2 / mainCanvas.width * Math.max(aspectRatio, 1),
  2 / mainCanvas.height * Math.min(aspectRatio, 1),
);
viewMatrix.translateSelf(-(mainCanvas.width / 2), -(mainCanvas.height / 2));

const enqueueFrame = (() => {
  let framePending = false;

  const renderFrame = async () => {
    framePending = true;
    const commandEncoder = device.createCommandEncoder();

    const uniforms = new Float32Array([
      ...viewMatrix.toFloat32Array(),
      parseFloat(iterationsRange.value),
      parseFloat(aRange.value),
      parseFloat(bRange.value)
    ]);
    device.queue.writeBuffer(buffer, 0, uniforms, 0, uniforms.length);

    const renderPass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        loadOp: "clear",
        clearValue: {r: 0, g: 0, b: 0, a: 0},
        storeOp: "store",
      }],
    });
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, bindGroup);
    renderPass.draw(6);
    renderPass.end();

    const commandBuffer = commandEncoder.finish();

    await device.queue.submit([commandBuffer]);
    framePending = false;
  };

  return () => {
    if (!framePending) {
      renderFrame();
    }
  };
})();

enqueueFrame();

mainCanvas.addEventListener("pointerdown", (e) => {
  const {offsetX: startOffsetX, offsetY: startOffsetY} = e;
  const startViewMatrix = viewMatrix.toString();

  const handlePointermove = (e) => {
    const {offsetX: currentOffsetX, offsetY: currentOffsetY} = e;

    viewMatrix.setMatrixValue(startViewMatrix);
    const dx = startOffsetX - currentOffsetX;
    const dy = startOffsetY - currentOffsetY;
    viewMatrix.translateSelf(dx, dy);

    enqueueFrame();
  };

  const stopListening = (e) => {
    mainCanvas.releasePointerCapture(e.pointerId);
    mainCanvas.removeEventListener("pointermove", handlePointermove);
    mainCanvas.removeEventListener("pointerup", stopListening);
    mainCanvas.removeEventListener("pointercancel", stopListening);
  };

  mainCanvas.setPointerCapture(e.pointerId);
  mainCanvas.addEventListener("pointermove", handlePointermove);
  mainCanvas.addEventListener("pointerup", stopListening);
  mainCanvas.addEventListener("pointercancel", stopListening);
});

mainCanvas.addEventListener("wheel", (e) => {
  const {deltaY, offsetX, offsetY} = e;

  const scale = 2 ** (deltaY / 128);
  viewMatrix.scale3dSelf(scale, offsetX, offsetY);

  enqueueFrame();
});

new ResizeObserver((entries) => {
  const {width: oldWidth, height: oldHeight} = mainCanvas;
  const {width: newWidth, height: newHeight} = entries.at(-1).contentRect;

  const dx = oldWidth / 2 - newWidth / 2;
  const dy = oldHeight / 2 - newHeight / 2;
  viewMatrix.translateSelf(dx, dy);

  mainCanvas.width = newWidth;
  mainCanvas.height = newHeight;

  context.configure({
    device,
    format: context.getPreferredFormat(adapter),
  });

  enqueueFrame();
}).observe(mainCanvas);

iterationsRange.addEventListener("input", () => {
  enqueueFrame();
});

aRange.addEventListener("input", () => {
  enqueueFrame();
});

bRange.addEventListener("input", () => {
  enqueueFrame();
});
</script>
